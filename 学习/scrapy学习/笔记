### 第一天 ###
首先需要安装scrapy，在终端执行以下命令
scrapy startproject scrapy_tang             # 当前路径下创建一个叫scrapy_tang的scrapy项目
cd scrapy_tang                              # 进入到项目目录下
scrapy genspider itcast itcast.cn           # 创建一个爬虫项目，爬虫项目的名字叫itcast， 仅限于爬取itcast.cn的数据
scrapy_tang/scrapy_tang/spiders/itcast.py   # 会有一个对应的文件

scrapy crawl itcast


logging模块的使用，可以创建一个logger对象，在其他的py文件中使用



函数中使用变量
函数寻找变量的顺序：函数自身--外部函数--全局变量--内置模块--报错
函数首先会在函数内寻找对应的局部变量，如果没有将回去寻找全局变量
global 变量名      在函数中修改全局变量时引用
nonlocal 变量名    引用上层函数的局部变量，适用于在函数的子函数中修改函数局部变量，如果在子函数中使用global默认调用的是全局变量
当全局变量为可变类型时，在函数中调用不需要加global，如：列表、字典、元祖属于可变类型

如：
s = 10
def func():
    global s    # 如果不加默认寻找局部变量，修改全局变量时使用
    s +=5
func()
print(s)        # 这里输出的s的值则为15


作用域
    globals()
    locals()
print(globals())        # 查看当前py文件全局变量（系统默认产生、自定义），输出的格式为字典，变量名为key，值为value
print(locals())         # 查看局部变量，在函数中，会列出函数中的局部变量，输出的格式为字典，同globals

闭包：
    1、在一个函数中定义了一个内部函数
    2、内部函数使用了外部函数的变量
    3、外部函数的返回值是内层函数
闭包的好处，延迟内存的回收，便于下次使用
"""
a = 2
b = 3
c = 10
def func1():
    global b
    b += 9
    c = 20
    def func2():
        nonlocal c
        c +=80
        v = c+b
        print("v =", v)
    return func2
f2 = func1()
f2()
"""


装饰器：
    1、定义函数，遵循闭包原则，函数作为参数使用
装饰带参数与不带参数函数
装饰带返回值的函数
装饰器参数：
多层装饰器：
    谁离函数近就先执行哪个装饰器，将第一层装饰器的返回结果给第二层装饰器



可迭代的：Iterable
迭代器：Iterator
生成器：generator
可迭代的不一定是迭代器，迭代器一定是可迭代的，可以通过iter()函数将可迭代的转换为迭代器

生成器：
    generator
    1、使用推导式使用的符号()
    2、函数+yield
        需要先定义函数，在函数中需要使用关键子yield，调用函数得到一个生成你对象，再结合next
        只要遇到yield则回i爱你搞起后面值返回并暂停，下次执行时，从该位置开始
        一个函数中可以有多个yield
        如果函数有返回值，返回值的内容会作为生成器元素取完后报错的内容：StopIteration：生成器函数返回值
多任务的应用：
    1、协程、
取出生成器中的值
    next(生成器)
    生成器.__next__()  同上

往生成器中传值
    sed(值)
    注意：第一个值必须要使用None，后面可以根据生成器传值


递归函数
    在函数的定义中调用函数自身，递归函数
    递归函数的遵循原则：
        1、递归函数必须要有出口，否则即为死循环
        2、不断的向出口靠近


类中的属性私有化与定义
    set和get的使用
    隐藏属性，只能在类中使用，对私有属性的赋值与取值限制在类中
装饰器：
    加装饰器，对函数名更加简要，让使用这在调用或者访问的时候更贱简单好用
    set方法：
        @属性名.setter
        def 属性名.(self, 参数)
            pass
使用：
    对象=类名(参数)
    print(对象.属性名)           # 类似与get方法
    对象.属性名 = 值              # 类似与set方法


继承：



""""
队列的特点：
    FIFO
    queue = Queue(3)        # 创建一个queue对象，且队列中的最多三个
    put("参数")      队列中存放参数， 参数timeout为超时时间，单位秒
    get()           取出队列中的参数，参数timeout为超时时间，单位秒
    full()          判断队列是否已满，返回值为True表示满，False则表示未满
    qsize()         查看队列长度，注意：在macos中无法执行 # Raises NotImplementedError on Mac OSX because of broken sem_getvalue()
    close()         关闭队列

进程适用于cpu密集的，即物理设备cpu资源较多的，如科学计算
线程是适用于IO密集，如读写操作多的爬虫，线程是调度的最小单位
一个进程包含一个或多个线程

什么是进程：
进程是程序的一次动态执行过程，每个进程度拥有自己的地址空间、内存、数据栈一技其他用于跟踪执行的辅助数据
操作系统负责其上所有的进程的执行，操作系统会位这个进程合理的分配执行时间
什么是线程：
线程是操作系统能够进行运算的调度的最小单位，它被包含在进程之中，是进程中的实际运作单位
一个线程只得是进程中一个单一的控制流，一个进程中可以并发多个线程，每条线程执行不同的任务
一个线程是一个execution context（执行上下文），即一个cpu执行时所需要的一串指令
主线程：
线程就是创建进程的第一个线程，也就是main函数对应的线程

创建线程：
    t3 = Thread(target=task3)

线程中方法：
    run
    start
    join
    name        查看线程名，默认的线程名Thread-1，第二个Thread-2...
    is_alive    判断是否存活
在线程中，如果有全局变量是每个线程之间共享，这样就有一个问题：就是可能我不同的线程在重复处理一件事

GIL全局共享锁

死锁：
    1、两把锁
    2、申请锁不当
在开发过程中使用使用线程，在线程间共享多个资源的时候，如果两个线程分别占有一种资源并且同时等待对方的资源，就会造成死锁
尽管死锁很少发生，但一旦发生就会造成停止响应，程序不做任何事
避免死锁：
    1、重构代码
    2、使用timeout参数

线程间通信：
    生产者与消费者（线程）

协程（微线程）
    greenlet
    gevent


